syntax = "proto3";
package webpush;

option go_package = "github.com/costinm/wpgate/pkg/msgs";

// Common fields to be encoded in the 'data' proto
message MessageData {

    // Time when the message was sent, according to the sender clock.
    int64 time = 1;

    // Original ID. If missing, the envelope ID will be used.
    string id = 2;

    // Original destination
    string to = 3;

    string from = 4;

    string topic = 5;

    map<string, string> meta = 6;
    bytes data = 7;
}

// Message is returned as PUSH PROMISE frames in the spec. The alternative protocol wraps it in
// Any field or other framing.
message WebpushMessage {

    // Unique in context of the origin
    // For webpush, generated by the original server (from subscription), as Location:
    // Example: https://push.example.net/message/qDIYHNcfAIPP_5ITvURr-d6BGt
    string id = 1;

    // Plaintext = 0
    // aes128gcm = 1
    int32 content_encoding = 7;

    // If encoding is "1" - aes128gcm
    // Otherwise it is a plaintext message.
    bytes data = 3;

    // Visible metadata, used for routing
    //map<string, string> meta = 8;

    // Message path
    repeated Via path = 6;

    int32 ttl = 9;

    // Maps to the SubscribeResponse push parameter, returned as Link rel="urn:ietf:params:push"
    // in the push promise.
    string push = 2;

    // Identifies the sender - compact form.
    Vapid sender = 4;

    // URL or IPv6, extracted from the VAPID of the sender or other
    // form of authentication.
    string from = 5;
}

message Via {
    int64 time = 1;

    string vip = 2;

    // bytes sig = 3;
}

// Vapid is the proto variant of a Webpush JWT.
// This is a more compact representation, without base64 overhead
//
// For HTTP, included in Authorization header:
// Authorization: vapid t=B64url k=B64url
//
// Decoded t is of form: { "typ": "JWT", "alg": "ES256" }.JWT.SIG
//
// { "crv":"P-256",
//   "kty":"EC",
//   "x":"DUfHPKLVFQzVvnCPGyfucbECzPDa7rWbXriLcysAjEc",
//   "y":"F6YK5h4SDYic-dRuU_RCPCfA5aq9ojSwk5Y2EmClBPs" }
message Vapid {
    // json payload of VAPID ( without base64 encoding)
    // Can also be a proto message when used over other transports.
    // Verification requires converting back to base64 !
    // Decoded to reduce the binary size
    bytes data = 7;

    // Public key of the signer, 64 bytes, EC256, decoded.
    // Included in 'k' parameter for HTTP.
    bytes k = 4;

    // If empty, it is assumed to be the constant value {typ=JWT,alg=ES256}
    bytes t_type = 32;

    // Decoded
    bytes t_signature = 33;
}

////
//message SubscribeRequest {
//
//    // A UA should group subscriptions in a set. First request from a
//    // UA will not include a set - it is typically a subscription associated with
//    // the UA itself.
//    string push_set = 1;
//
//    // Included as Crypto-Key: p256ecdsa parameter.
//    // Corresponds to the applicationServerKey parameter in the PushSubscriptionOptions in
//    // the W3C API
//    string sender_vapid = 2;
//}
//
//// Subscribe response includes the elements in the spec.
//message SubscribeResponse {
//    // Returned as Link: rel="urn:ietf:params:push"
//    // Spec examples use a full path ( /push/xxxx1 )
//    // TODO: clarify if it can be a full URL
//    string push = 1;
//
//    // Optional response: it
//    // returned as Link: rel=urn:ietf:params:push:set
//    // Spec examples use a full path ( /subscription-set/xxxx2 ).
//    // TODO: clarify it can be a full URL, like subscription
//    string push_set = 2;
//
//    // Push subscription resource. This is the full URL where the UA will use to
//    // receive the messages, using the PUSH promise http2 frame.
//    //
//    //
//    // Returned as Location header in the spec
//    string location = 3;
//}

message PushRequest {
    // The value returned in the SubscribeResponse push, without the hostname.
    string push = 1;

    int32 ttl = 2;

    // aes128gcm encrypted
    bytes data = 3;

    string urgency = 4;

    // Prefer header indicating delivery receipt request.
    bool respond_async = 5;

    string topic = 6;
}

message PushResponse {
  string message_id = 1;

  // If request includes the respond_async parameter.
  //
  string push_receipt = 2;
}

//message MonitorRequest {
//    // This is the push or push_set in the subscribe response.
//    string push_set = 1;
//
//    // JWT token, signed with key
//    string authorization = 2;
//
//    // Public key used for signing, identifies sender/receiver
//    string key = 3;
//}

//message AckRequest {
//    string message_id = 1;
//
//    // Optional, not part of the spec: if the subscribe request was authenticated with VAPID,
//    // the delete should also be authenticated with same VAPID key
//}

//message AckResponse {
//}

//message ReceiptRequest {
//    string receipt_subscription = 1;
//}

//message Receipt {
//    string message_id = 1;
//}

// Not implemented - alternative interface with explicit methos for each operation.
//service Webpush {
//    // Subscribe maps the the webpush subscribe request
//    rpc Subscribe (SubscribeRequest) returns (SubscribeResponse) {
//    }
//
//    // Monitor allows a UA to receive push messages from the push service
//    // Replaced push promises with a stream of Message objects.
//    rpc Monitor(MonitorRequest) returns (stream Message) {}
//
//    rpc Ack(AckRequest) returns (AckResponse) {}
//
//    // Push allows an application server to send messages to UA, using the push service.
//    rpc Push(PushRequest) returns (PushResponse) {}
//
//    // Monitor allows an AS to receive push messages receipts from the push service
//    // Replaced push promises with a stream of Message objects.
//    rpc Receipts(ReceiptRequest) returns (stream Receipt) {}
//}

