package main

import (
	"fmt"

	"github.com/costinm/ugate"
	"github.com/costinm/ugate/pkg/iptables"
	"github.com/costinm/ugate/pkg/socks"
	"github.com/costinm/ugate/pkg/ugatesvc"
)


//
// WIP:
// - Listens as H2C, using certs generated by krun
// - Forwards /hbone/PORT to port
// - Handles /hbone/mtls as mtls and forwards to 8080 as H2C
// - intercepts egress with iptables, forwards to a gate.
//
func main() {
	config := ugatesvc.NewConf(".", "./var/lib/dmesh",
		"./var/run/secrets/istio.io", "/var/run/secrets/istio.io")

	cfg := &ugate.GateCfg{
		BasePort: 14000,
	}

	// Start a Gate. Basic H2 and H2R services enabled.
	ug := ugatesvc.New(config, nil, cfg)

	// Inbound path
	// TODO: create reverse tunnel to ugate
	// go ug.H2Handler.UpdateReverseAccept()

	// Ingress using H2C, for example in CloudRun.
	btscAddr := fmt.Sprintf("0.0.0.0:%d", cfg.BasePort+ugate.PORT_BTSC)
	ug.StartListener(&ugate.Listener{
		Address:  btscAddr,
		Protocol: ugate.ProtoBTSC,
	})

	// WIP: egress side
	// capture using iptables, socks, port
	go iptables.IptablesCapture(ug, fmt.Sprintf("0.0.0.0:%d", cfg.BasePort + 1), false)
	go iptables.IptablesCapture(ug, fmt.Sprintf("0.0.0.0:%d", cfg.BasePort + 6), true)
	socks.New(ug)
	ug.Config.Listeners[":10001"] = &ugate.Listener {
		ForwardTo: "localhost:5201",
	}
	ug.Config.Listeners[":10002"] = &ugate.Listener {
		ForwardTo: "localhost:8080",
	}

	//
	// TODO: get out endpoints using a metadata server ( backed by pilot-agent )
	// or XDS.
	// TODO: configure an multi-network gateway, with SNI or BTS

	// VIPs for iptables capture test. Redirect to local host, to bench
	// 1-hop iptables capture, in TCP mode
	ug.Config.Routes["10.1.1.2:8080"] = &ugate.Route {
		ForwardTo: "localhost:8080",
	}
	ug.Config.Routes[":8081"] = &ugate.Route {
		ForwardTo: "localhost:8080",
	}
	ug.Config.Routes["10.1.1.3:5201"] = &ugate.Route {
		ForwardTo: "localhost:5201",
	}

	ug.Start()

	select {}
}
